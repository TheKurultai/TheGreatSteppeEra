#textdomain wesnoth-units

#define ABILITY_OGREFACTION
    [dummy]
        id=ogrefaction
    [/dummy]
#enddef

#define ABILITY_STEPPE_CATTLE
#dummy ability to show the unit has no upkeep, but also a proper ability that makes the unit not capture villages
    [dummy]
        id=steppe_cattle
        {TRANSLATE_ABILITY "cattle" "скот"}
        {TRANSLATE_DESCRIPTION _"This unit costs no upkeep, but is unable to capture villages." _"Скот не имеет содержания, но и не может захватывать деревни."}
    [/dummy]
     # wmlxgettext: [abilities]
[/abilities]
#cattle can't capture villages
[event]
    name=capture
    first_time_only=no
    [filter]
            ability=steppe_cattle
    [/filter]
    [allow_undo] [/allow_undo]
    [capture_village]
        ## reset ownership to prior Side
        x,y=$x1,$y1
        side=$owner_side
        fire_event=no
    [/capture_village]
    [/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef



#define EVENTLOADER_EVENTS_OGRE
    [event]
    # is used to show icon in status bar
         name=preload
         first_time_only=no
         id=show_imprisoned
         [lua]
             code=<<
                 local _ = wesnoth.textdomain "wesnoth-imprisoned"
                 local old_unit_status = wesnoth.theme_items.unit_status
                 function wesnoth.theme_items.unit_status()
                     local u = wesnoth.get_displayed_unit()
                     if not u then return {} end
                     local s = old_unit_status()
                     if u.status.captured then
                         table.insert(s, { "element", {
                             image = "items/cage.png~SCALE(20,20)",
                             tooltip = _"Captured: This unit is captured. It cannot move, or attack, has no ZoC, and it's defense on all mainline types of terrain is reduced by 10%, but the unit can still retaliate, and doesn't cost any upkeep to his side. After several turns pass without the unit being freed, the unit is automatically sold into slavery."
                         } })
                     end
                     return s
                 end
             >>
         [/lua]
    [/event]
#currently disabled, might be used for another faction later on:
[event]
id=ogre_rushevent
name=recruit,recall
first_time_only=no
[filter]
ability=ogrefaction_unused#currently unused
#[not]
#    canrecruit=yes
#[/not]
[/filter]
[if]
{VARIABLE_CONDITIONAL ogreera_disablerush not_equals yes}
[then]
{VARIABLE unit.moves "$($unit.moves| + ($unit.max_moves| / 2) )"}
[unstore_unit]
variable=unit
#ifdef OGRE_RUSSIAN
    text= _"Вперед!"
#else
    text= _ "Charge!"
#endif
red=0
green=255
blue=0
[/unstore_unit] 
{CLEAR_VARIABLE raidermoves}
[/then]
[/if]
[/event]
#free all prisoners on leader death:
[event]
    name=die
    id=steppe_ogre_freeprisoners
    first_time_only=no
    [filter]
            canrecruit=yes
    [/filter]

    [if]
    [not]
    [have_unit]
    canrecruit=yes
    side=$unit.side
    [/have_unit]
    [/not]
    [then]

    {FOREACH capture_unit_information a}
        [if]
            [variable]
                name=capture_unit_information[$a].seller_side
                equals=$unit.side
            [/variable]
            [then]
            [store_unit]
                [filter]
                   id=$capture_unit_information[$a].id
                [/filter]
                variable=leaderdeath_freeunit
                kill=no
            [/store_unit]
            {STEPPE_FREEUNIT $leaderdeath_freeunit.x $leaderdeath_freeunit.y}
            {CLEAR_VARIABLE leaderdeath_freeunit}
            [/then]
        [/if]
    {NEXT a}
    [/then]
    [/if]
[/event]
[event]
    name=pre advance
    id=steppe_ogre_scale_cage_image_event1
    first_time_only=no
    [filter]
      ability=steppe_captured
    [/filter]

    [remove_unit_overlay]
        id=$unit.id
        image="items/cage.png~SCALE($unit.variables.cage_image_size_width|,$unit.variables.cage_image_size_height|)"
    [/remove_unit_overlay]
[/event]

[event]
    name=post advance
    id=steppe_ogre_scale_cage_image_event2
    first_time_only=no
    [filter]
      ability=steppe_captured
    [/filter]

    {STEPPE_LUA_CALCULATE_UNIT_SPRITE_SIZE unit steppe_cagesize_calc_width steppe_cagesize_calc_height}

    {VARIABLE unit.variables.cage_image_size_width $steppe_cagesize_calc_width}
    {VARIABLE unit.variables.cage_image_size_height $steppe_cagesize_calc_height}

    [unstore_unit]
        variable=unit
        find_vacant=no
    [/unstore_unit]

    [unit_overlay]
        id=$unit.id
        image="items/cage.png~SCALE($unit.variables.cage_image_size_width|,$unit.variables.cage_image_size_height|)"
    [/unit_overlay]
[/event]

[event]
    name=start
    id=steppe_cagecalculator_menu
    first_time_only=no

#clear the burning tile and destroyed village variables, for multiplayer campaign. This isn't exactly airtight (it won't work if the mad changes mid-battle, but otherwise should be good enough for campaigns)
    {CLEAR_VARIABLE burning_tile_information}
    {CLEAR_VARIABLE destroyed_village_information}

    [set_menu_item]
        id=steppe_cagecalculator
#ifdef OGRE_RUSSIAN
        description="Подсчитать освобождаемость этого юнита"
#else
        description="Calculate whether this unit can freed"
#endif
        image=items/book2.png~CROP(21,23,27,24)~SCALE(20,20)
        #DO NOT SET SYNCED TO NO FOR ANY MENUS THAT ACTUALLY AFFECT THE GAME!!!
        synced=yes
        [show_if]
        {VARIABLE_CONDITIONAL steppe_disable_calculator_menu not_equals yes}
        [/show_if]

        [filter_location]
            [filter]
                ability=steppe_captured
            [/filter]
        [/filter_location]
        [command]
    [allow_undo] [/allow_undo]

    [store_unit]
        [filter]
            x,y=$x1,$y1
        [/filter]

        variable=steppe_cagecalc_unit
        kill=no
    [/store_unit]

    {VARIABLE freer_points 0}
    {VARIABLE capturer_points 0}

    [if]
    [have_unit]
            id=$steppe_cagecalc_unit.id
            [filter_side]
            [allied_with]
                side=$side_number
            [/allied_with]
            [/filter_side]
    [/have_unit]
    [then]
    {VARIABLE steppe_cagecalc_freer_color 00ff00}
    {VARIABLE steppe_cagecalc_capturer_color ff0000}
    [/then]
    [else]
    {VARIABLE steppe_cagecalc_freer_color ff0000}
    {VARIABLE steppe_cagecalc_capturer_color 00ff00}
    [/else]
    [/if]

#macro from below
    {STEPPE_CAGE_LEVELCALC steppe_cagecalc_unit $x1 $y1}

    [if]
    {VARIABLE_CONDITIONAL freer_points greater_than $capturer_points}
    [then]

#ifdef OGRE_RUSSIAN
    {VARIABLE steppe_cagecalc_canfree Да}
#else
    {VARIABLE steppe_cagecalc_canfree Yes}
#endif

    {VARIABLE steppe_cagecalc_canfree_color $steppe_cagecalc_freer_color}

    [/then]
    [else]

#ifdef OGRE_RUSSIAN
    {VARIABLE steppe_cagecalc_canfree Нет}
#else
    {VARIABLE steppe_cagecalc_canfree No}
#endif

    {VARIABLE steppe_cagecalc_canfree_color $steppe_cagecalc_capturer_color}

    [/else]
    [/if]
 
        [message]
            speaker=narrator
            side_for=$side_number
#ifdef OGRE_RUSSIAN
            caption=_"Подсчет освобождаемости"
            message=_"Сумарный уровень пленителей: <span color='#$steppe_cagecalc_capturer_color|'>$capturer_points|</span> 

Сумарный уровень освободителей: <span color='#$steppe_cagecalc_freer_color|'>$freer_points|</span>

Освободить можно: <span color='#$steppe_cagecalc_canfree_color|'>$steppe_cagecalc_canfree|</span>

(примечание: перевес уровней может легко изменится за ход врага)"
#else
            caption=_"Disloyal desert-ability calculator"
            message=_"Total capturer levels: <span color='#$steppe_cagecalc_capturer_color|'>$capturer_points|</span>

Total level of freers: <span color='#$steppe_cagecalc_freer_color|'>$freer_points|</span>

Can the unit be freed: <span color='#$steppe_cagecalc_canfree_color|'>$steppe_cagecalc_canfree|</span>

(note: this menu only calculates only the <b>current</b> total levels, which can easily change during an enemy's turn)"
#endif
            image=portraits/factionhint-ogre.png
        [/message]

    {CLEAR_VARIABLE freer_points}
    {CLEAR_VARIABLE capturer_points}
    {CLEAR_VARIABLE capturer_points1}
    {CLEAR_VARIABLE capturer_points2}
    {CLEAR_VARIABLE steppe_cagecalc_unit}
    {CLEAR_VARIABLE steppe_cagecalc_canfree}
    {CLEAR_VARIABLE steppe_cagecalc_oversight}
    {CLEAR_VARIABLE steppe_cagecalc_oversight_true}
    {CLEAR_VARIABLE steppe_cagecalc_capturer_color}
    {CLEAR_VARIABLE steppe_cagecalc_freer_color}
    {CLEAR_VARIABLE steppe_cagecalc_canfree_color}

        [/command]
    [/set_menu_item]
[/event]
#enddef

#define STEPPE_DESTROYVILLAGE ARSONVAR TERRAIN
    [store_locations]
        x,y=$x1,$y1
        variable=tmp_steppe_village_location
    [/store_locations]
    [set_variables]
        name=destroyed_village_information
        mode=append
        [value]
            x=${ARSONVAR}.x
            y=${ARSONVAR}.y
            terrain=$tmp_steppe_village_location.terrain
        [/value]
    [/set_variables]
    {CLEAR_VARIABLE tmp_steppe_village_location}
[terrain]
terrain={TERRAIN}
x,y=${ARSONVAR}.x,${ARSONVAR}.y
layer=overlay
[/terrain]
    [if]
    [have_unit]
        id=${ARSONVAR}.id
        ability=steppe_arsontype_trample
    [/have_unit]
    [then]
    [item]
        x=${ARSONVAR}.x
        y=${ARSONVAR}.y
        name=steppe_rubble
        image=scenery/rubble.png
    [/item]
    [/then]
    [else]
    {RANDOM 1..4}
    [item]
        x=${ARSONVAR}.x
        y=${ARSONVAR}.y
        name=steppe_burnedvillage
        image=scenery/village-human-burned$random|.png
    [/item]
#fixed tarbynns creating fire when destroying villages
    [if]
    [have_unit]
        id=${ARSONVAR}.id
        ability=steppe_arsontype_tarbynn
    [/have_unit]
    [else]
    [item]
        x=${ARSONVAR}.x
        y=${ARSONVAR}.y
        name=steppe_flames
        halo=scenery/flames[01~15].png:50
    [/item]
    [sound_source]
        id=steppe_flames_${ARSONVAR}.x|_${ARSONVAR}.y|
        sounds=ambient/campfire.ogg
        delay=9000
        chance=100
        check_fogged=no
        check_shrouded=yes
        x,y=${ARSONVAR}.x,${ARSONVAR}.y
        full_range=5
        fade_range=3
        loop=-1
    [/sound_source]
    [set_variables]
        name=burning_tile_information
        mode=append
        [value]
            x=${ARSONVAR}.x
            y=${ARSONVAR}.y
            turn_of_extinguish=$"($turn_number| + 3)"
            turn_of_true_extinguish=$"($turn_number| + 6)"
        [/value]
    [/set_variables]
    [/else]
    [/if]
    [/else]
    [/if]
    [store_side]
        side=${ARSONVAR}.side
        variable=arsonistside
    [/store_side]
#    {VARIABLE arsongold "$($arsonistside.village_gold| * (2 + ${ARSONVAR}.level|))"}
    {VARIABLE arsongold "$($arsonistside.village_gold| * 2 + 1)"}
        {MODIFY_UNIT x,y=${ARSONVAR}.x,${ARSONVAR}.y attacks_left 0}
#    [scroll_to]
#        x,y=${ARSONVAR}.x,${ARSONVAR}.y
#    [/scroll_to]
    [gold]
        side=$side_number
        amount=$arsongold
    [/gold]
    [sound]
      name=gold.ogg
    [/sound]
    #give experience for burning down villages:
    {VARIABLE_OP {ARSONVAR}.experience add 3}
        [unstore_unit]
            variable={ARSONVAR}
#ifdef OGRE_RUSSIAN
            text="$arsongold| золота"
#else
            text="$arsongold|g"
#endif
            red=255
            green=255
            blue=0
            find_vacant=no
        [/unstore_unit]
    [fire_event]
        name=post pillage
        [primary_unit]
            x,y=$x1,$y1
        [/primary_unit]
    [/fire_event]    
#enddef

#define ARSONEVENT ARSONVAR
{IF_VAR steppe_disable_pillage_scrolling not_equals yes (
[then]
    [scroll_to]
        x,y=${ARSONVAR}.x,${ARSONVAR}.y
    [/scroll_to]
[/then]
)}

    [if]
    [have_unit]
        id=${ARSONVAR}.id
        ability=steppe_arsontype_tarbynn
    [/have_unit]
    [then]
    [sound]
        name=magic-dark-big.ogg
    [/sound]
    [delay]
        time=120
    [/delay]
    [sound]
        name=wose-die.ogg
    [/sound]
    [delay]
        time=180
    [/delay]
    {STEPPE_DESTROYVILLAGE {ARSONVAR} ^}
    [/then]
    [else]

    [if]
    [have_unit]
        id=${ARSONVAR}.id
        ability=steppe_arsontype_trample
    [/have_unit]
    [then]
    [sound]
        name=horse-canter.wav
    [/sound]
    [delay]
        time=120
    [/delay]
    [sound]
        name=mace.ogg
    [/sound]
    [delay]
        time=220
    [/delay]
    [sound]
        name=wose-die.ogg
    [/sound]
    [delay]
        time=180
    [/delay]

#    {STEPPE_DESTROYVILLAGE {ARSONVAR} ^Es}
    {STEPPE_DESTROYVILLAGE {ARSONVAR} ^}
    [/then]
    [else]
    [sound]
#        name=melee-fire.ogg
        name=fire.wav
    [/sound]
    [delay]
        time=120
    [/delay]
    [sound]
        name=fire.wav
    [/sound]
    [delay]
        time=220
    [/delay]
    [sound]
        name=wose-die.ogg
    [/sound]
    [delay]
        time=180
    [/delay]
    [sound]
        name=torch-miss.ogg
    [/sound]
    {STEPPE_DESTROYVILLAGE {ARSONVAR} ^Ecf}
    [/else]
    [/if]
    [/else]
    [/if]

#        {MODIFY_UNIT x,y=${ARSONVAR}.x,${ARSONVAR}.y moves $(${ARSONVAR}.max_moves / 3|)}
        {MODIFY_UNIT x,y=${ARSONVAR}.x,${ARSONVAR}.y moves 0}
    [delay]
       time=200
    [/delay]

        [modify_unit]
            [filter]
                id=${ARSONVAR}.id
            [/filter]
            [status]
                poisoned=no
            [/status]
        [/modify_unit]
        [heal_unit]
            [filter]
                id=${ARSONVAR}.id
            [/filter]
            amount=8
            animate=yes
            restore_statuses=no
        [/heal_unit]

        {CLEAR_VARIABLE arsonmoves}
        {CLEAR_VARIABLE arsongold}
        {CLEAR_VARIABLE arsonist}
        {CLEAR_VARIABLE arsonistside}
#enddef

#define ABILITY_PILLAGE TYPE
    # Canned definition of the Pillage ability to be included in an
    # [abilities] clause.  Note: this is deliberately unbalanced WML,
    # in order to close the abilities clause then insert the event
    # then reopen the abilities clause.
    [dummy]
        id=steppe_pillage
        {TRANSLATE_ABILITY "pillage" "мародерство"}
#so the ability is invisible when inactive:
        name_inactive=""
        female_name_inactive=""
        {TRANSLATE_DESCRIPTION _"Whener this unit kills an enemy, they earn their side an amount of gold equal to 75% (rounded up) of the killed enemy's gold cost.

        When moving onto a village, this unit automatically destroys it, giving the arsonist's side some gold (equal to 2+1 times the side's village gold setting), giving the unit 3 experience, healing the unit by 8 HP and removing poison. This ability does not work while enslaved. If a unit with pillage is leader (except in RPG), the side gains a bit of extra income to compensate for the faction usually not being able to hold villages." _"Когда мародёр убивает врага, его сторона получает золото, равное 75% (округляется ввёрх) стоимости убитого юнита. Если мародёр становится в деревню, то он сжигает её, а его сторона получает золото, равное доходу деревни за 2 хода +1, мародер получает 3 опыта, лечится на 8 ЗД и убирает яд. Порабощённые юниты теряют мародерство (но оно возвращается, если их освободить). Если лидер (кроме в РПГ) имеет эту способность, то его сторона получает небольшой бонусный доход, чтобы компенсировать невозможность держать деревни."}
        [filter]
        [not]
            ability=steppe_slave
        [/not]
        [/filter]
    [/dummy]
    [dummy]
        id=steppe_arsontype_{TYPE}
    [/dummy]
    # wmlxgettext: [abilities]
[/abilities]
[event]
    name=moveto
    id=steppe_arson_event
    first_time_only=no
    [filter]
            ability=steppe_pillage
    [filter_location]
            terrain=*^V*
    [/filter_location]
        [not]
            ability=steppe_slave
        [/not]
    [/filter]
    [store_unit]
        [filter]
           x,y=$x1,$y1
        [/filter]
        variable=arsonist
        kill=no
    [/store_unit]
    {ARSONEVENT arsonist}
[/event]
[event]
    id=steppe_pillaging_event
    name=die
    first_time_only=no

    [filter]
    [not]
        ability=steppe_notrigger_onkill_abilities
    [/not]
    [/filter]

    [filter_second]
        ability=steppe_pillage
        [not]
            ability=steppe_slave
            [or]
            ability=steppe_notrigger_onkill_abilities
            [/or]
        [/not]
    [/filter_second]

        [store_unit]
            [filter]
                 x,y=$x1,$y1
            [/filter]
            variable=lootedunit
        [/store_unit]
        [store_unit_type]
            type=$lootedunit.type
            variable=lootedunittype
        [/store_unit_type]
        {VARIABLE lootgold "$($lootedunittype.cost| * 0.75)"}
        {VARIABLE_OP lootgold round ceil}
    [gold]
        side=$second_unit.side
        amount=$lootgold
    [/gold]
    [sound]
      name=gold.ogg
    [/sound]
        [unstore_unit]
            variable=second_unit
#ifdef OGRE_RUSSIAN
            text="$lootgold| золота"
#else
            text="$lootgold|g"
#endif
            red=255
            green=255
            blue=0
            find_vacant=no
        [/unstore_unit]
        {CLEAR_VARIABLE lootedunit}
        {CLEAR_VARIABLE lootedunittype}
        {CLEAR_VARIABLE lootgold}
[/event]
[event]
    name=side turn
    id=steppe_fireextinguish_event
    first_time_only=no
#    [chat]
#        message=_"fire extinguish event triggered"
#    [/chat]
    {FOREACH burning_tile_information i}
        [if]
            [variable]
                name=burning_tile_information[$i].turn_of_extinguish
                less_than_equal_to=$turn_number
            [/variable]

            [then]
#                [chat]
#                    message=_"fire extinguish event succeeded x: $burning_tile_information[$i].x, y: $burning_tile_information[$i].y"
#                [/chat]

                [remove_item]
                    x=$burning_tile_information[$i].x
                    y=$burning_tile_information[$i].y
                    image=steppe_flames
                [/remove_item]

 
#                [clear_variable]
#                    name=burning_tile_information[$i]
#                [/clear_variable]
            [/then]
        [/if]

        [if]
            [variable]
                name=burning_tile_information[$i].turn_of_true_extinguish
                less_than_equal_to=$turn_number
            [/variable]

            [then]
#                [chat]
#                    message=_"fire true extinguish event succeeded x: $burning_tile_information[$i].x, y: $burning_tile_information[$i].y"
#                [/chat]

                [terrain]
                terrain=^
                x,y=$burning_tile_information[$i].x,$burning_tile_information[$i].y
                layer=overlay
                [/terrain]
 
                [remove_sound_source]
                    id=steppe_flames_$burning_tile_information[$i].x|_$burning_tile_information[$i].y|
                [/remove_sound_source]

                [clear_variable]
                    name=burning_tile_information[$i]
                [/clear_variable]
            [/then]
        [/if]
    {NEXT i}
[/event]
[event]
    name=side turn 1
    id=steppe_ogre_income_bonus
    first_time_only=no

    [store_unit]
        [filter]
            side=$side_number
            canrecruit=yes
            ability=steppe_pillage
        [/filter]
        variable=tmp_pillage_leader
        kill=no
    [/store_unit]

    [store_side]
        side=$side_number
        variable=steppe_incomebonus_side
    [/store_side]

    [if]
    [have_unit]
        id=$tmp_pillage_leader.id
    [/have_unit]
    [and]
        {VARIABLE_CONDITIONAL steppe_incomebonus_side.recruit not_equals ""}#prevents the bonus for triggering in RPG
    [/and]
    [then]

#        [chat]
#            message=$steppe_incomebonus_side.income
#        [/chat]

        {VARIABLE tmp_newincome $steppe_incomebonus_side.income}
        {VARIABLE tmp_incomebonus $steppe_incomebonus_side.village_gold}
        {VARIABLE_OP tmp_incomebonus multiply 1.5}
        {VARIABLE_OP tmp_incomebonus round ceil}
        {VARIABLE_OP tmp_newincome add $tmp_incomebonus}

        [modify_side]
            side=$side_number
            income=$tmp_incomebonus
        [/modify_side]

        [unstore_unit]
            variable=tmp_pillage_leader
#ifdef OGRE_RUSSIAN
            text="+$tmp_incomebonus| дохода"
#else
            text="+$tmp_incomebonus| income"
#endif
            red=255
            green=255
            blue=0
            find_vacant=no
        [/unstore_unit]
    [/then]
    [/if]

    {CLEAR_VARIABLE tmp_pillage_leader}
    {CLEAR_VARIABLE steppe_incomebonus_side}
    {CLEAR_VARIABLE tmp_newincome}
    {CLEAR_VARIABLE tmp_incomebonus}
[/event]
[+abilities]
    # wmlxgettext: [/abilities]
#enddef
# wmllint: unbalanced-off

#for the slavers' capture ability:

#define STEPPE_DEFENSE_CHANGE VALUE
                    [effect]
                        apply_to=defense
            replace=no
              [defense]
            deep_water={VALUE}
                shallow_water={VALUE}
                swamp_water={VALUE}
                reef={VALUE}
                flat={VALUE}
                sand={VALUE}
                forest={VALUE}
                hills={VALUE}
                mountains={VALUE}
                village={VALUE}
                castle={VALUE}
                cave={VALUE}
                frozen={VALUE}
#               unwalkable={VALUE}
                fungus={VALUE}
              [/defense]
                    [/effect]
#enddef
#define STEPPE_DEFENSE_MPCOST_CHANGE VALUE MPCOST
                    [effect]
                        apply_to=defense
            replace=no
              [defense]
            deep_water={VALUE}
                shallow_water={VALUE}
                swamp_water={VALUE}
                reef={VALUE}
                flat={VALUE}
                sand={VALUE}
                forest={VALUE}
                hills={VALUE}
                mountains={VALUE}
                village={VALUE}
                castle={VALUE}
                cave={VALUE}
                frozen={VALUE}
#               unwalkable={VALUE}
                fungus={VALUE}
              [/defense]
                    [/effect]
                    [effect]
                        apply_to=movement_costs
            replace=no
              [movement_costs]
            deep_water={MPCOST}
                shallow_water={MPCOST}
                swamp_water={MPCOST}
                reef={MPCOST}
                flat={MPCOST}
                sand={MPCOST}
                forest={MPCOST}
                hills={MPCOST}
                mountains={MPCOST}
                village={MPCOST}
                castle={MPCOST}
                cave={MPCOST}
                frozen={MPCOST}
                unwalkable={MPCOST}
                fungus={MPCOST}
              [/movement_costs]
                    [/effect]
#enddef

#define STEPPE_FREEUNIT X Y
[if]
[have_unit]
    x,y={X},{Y}
    ability=steppe_captured
[/have_unit]
[then]
            [modify_unit]
              [filter]
                 x,y={X},{Y}
              [/filter]
              upkeep=full
            [/modify_unit]
            [object]
                silent=yes
#                duration=scenario
                [filter]
                    x,y={X},{Y}
                [/filter]
            [effect]
                apply_to=attack
                remove_specials=steppe_defense_only2
            [/effect]
            [effect]
                apply_to=remove_ability
                [abilities]
                  [dummy]
                     id=steppe_captured
                  [/dummy]
                [/abilities]
            [/effect]   
#            {STEPPE_DEFENSE_MPCOST_CHANGE -20 -90}
            {STEPPE_DEFENSE_MPCOST_CHANGE -10 -90}
            [/object]
        [store_unit]
            [filter]
                x,y={X},{Y}
            [/filter]
            variable=steppe_captured
            kill=no
        [/store_unit]
        [capture_village]
            side=$steppe_captured.side
            x,y={X},{Y}
        [/capture_village]
    {IF_VAR steppe_captured.level greater_than 0 (
    [then]
          {VARIABLE steppe_captured.zoc yes}
    [/then])}
        {VARIABLE steppe_captured_halfmp $steppe_captured.moves}
        {VARIABLE_OP steppe_captured_halfmp divide 2}
        {VARIABLE_OP steppe_captured_halfmp round floor}
        {VARIABLE steppe_captured.moves $steppe_captured_halfmp}
    {CLEAR_VARIABLE steppe_captured_halfmp}

#remove the unit from the list of captured units
    {FOREACH capture_unit_information c}
    {IF_VAR capture_unit_information[$c].id equals $steppe_captured.id (
        [then]
            {CLEAR_VARIABLE capture_unit_information[$c]}
        [/then]
    )}
    {NEXT c}
 
    [sound]
      name={SOUND_LIST:HOLY}
    [/sound]
        [unstore_unit]
            variable=steppe_captured
#ifdef OGRE_RUSSIAN
        text="Свобода!"
#else
        text="Freedom!"
#endif
        {COLOR_HEAL}
        find_vacant=no
        [/unstore_unit]
#        [chat]
#            message="$steppe_captured.id| $steppe_captured.variables.cage_image_size_width|,$steppe_captured.variables.cage_image_size_height|"
#        [/chat]
        [remove_unit_overlay]
            id=$steppe_captured.id
            image="items/cage.png~SCALE($steppe_captured.variables.cage_image_size_width|,$steppe_captured.variables.cage_image_size_height|)"
        [/remove_unit_overlay]
[/then]
[/if]
#enddef

#define STEPPE_CAGE_LEVELCALC UNITVAR X Y
    {TOTAL_LEVEL_CALC (
    [filter_side]
    [allied_with]
        side=${UNITVAR}.side
    [/allied_with]
    [/filter_side]
    [not]
            ability=steppe_captured
            [or]
              level=0
            [/or]
    [/not]
    [filter_location]
        x,y={X},{Y}
        radius=2
    [/filter_location]
    ) freer_points a}

    {TOTAL_LEVEL_CALC (
    [filter_side]
    [enemy_of]
        side=${UNITVAR}.side
    [/enemy_of]
    [/filter_side]
    [not]
            ability=steppe_captured
            [or]
              level=0
            [/or]
    [/not]
    [filter_location]
        x,y={X},{Y}
        radius=2
    [/filter_location]
    ) capturer_points a}
#enddef


#define WEAPON_SPECIAL_STEPPE_CAPTURE
    [dummy]
        id=steppe_capture
        {TRANSLATE_ABILITY "capture" "пленение" }
        {TRANSLATE_DESCRIPTION _"Instead of a killing units, this attack captures them instead. Captured units are put in a cage, moved behind the capturer, and, if not freed within 1 turn, are automatically sold into slavery, and the capturer side gains gold equal to 125% of the unit cost, and if the capturer unit still exists, they gain the same exp that they would get if they killed the unit. 

        While in a cage, the unit can't move/attack and their defense on all terrain is reduced by 10%, but they can still retaliate. If a unit that is on (or allied with) the side of of a captured unit moves next to them, and the total level of nearby allies (in a 2-tile radius from the unit) is higher than that of the nearby enemies (in a 2-tile radius from the unit), the captured unit is freed. The captured unit isn't sold if there are more freers than capturers adjacent to the cage (regardless of level difference).

        Does not work on buildings or enemies that are already captured." _"Эта атака не добивает врага, но захватывает его в плен. Пленники находятся в клетке, и при взятии в плен передвигаются за пленителя. Чтобы освободить пленника, нужно подвести к нему бойца, при этом сумма уровней освободителей в радиусе 2 гексов от пленного должна быть выше суммы уровней пленителей в радиусе 2 гексов. Если не освободить пленника в течение 1 хода, он будет продан: сторона пленителей получит золото, равное 125% стоимости пленника, а юнит-пленитель (если он жив) получит опыт, равный опыту за убийство пленника. Пленный не продается если возле него (радиус 1 клетка) стоит союзников больше, чем пленителей (несмотря на перевес уровней).

Не работает на зданиях или уже захваченных врагах."}
    [/dummy]
    [/specials]
[/attack]
[event]
    name=last breath
    id=steppe_capture_event
    first_time_only=no
    [filter]
    [not]
        ability=steppe_captured
    [or]
        ability=steppe_building
    [/or]
    [/not]
    [/filter]
   
    [filter_second_attack]
        special=steppe_capture
    [/filter_second_attack]

               [store_locations]
                   [not]
                       [filter]
                       [/filter]
                       [or]
                       terrain=M*,Q*,X*,Wo*^* #mountains, unwalkable, impassable, and deep water
                       [/or]
                   [/not]
   
                   [filter_adjacent_location]
                       x,y=$x2,$y2
                       adjacent=-$unit.facing
                   [/filter_adjacent_location]
   
                   variable=knockback_target_hex
               [/store_locations]

#reduces the capturer's exp, so that no exp is gained from capturing (to prevent exp exploits)
    {EXP_VALUE_CALC $unit.id steppe_captured_exp}
    [store_unit]
        [filter]
            id=$second_unit.id
        [/filter]
        variable=capturer_exp
        kill=no
    [/store_unit]
    {VARIABLE_OP capturer_exp.experience sub $steppe_captured_exp}
    {VARIABLE_OP capturer_exp.experience add $unit.level}#add exp equal to having attacked the unit normally
    [unstore_unit]
        variable=capturer_exp
        find_vacant=no
    [/unstore_unit]
    {CLEAR_VARIABLE capturer_exp}
    {CLEAR_VARIABLE steppe_captured_exp}

    {VARIABLE unit.hitpoints $unit.max_hitpoints}
    {VARIABLE_OP unit.hitpoints multiply 0.33}
#    {VARIABLE unit.status.captured yes}
    [sound]
      name=slowed.wav
    [/sound]

    {STEPPE_LUA_CALCULATE_UNIT_SPRITE_SIZE unit steppe_cagesize_calc_width steppe_cagesize_calc_height}

    {VARIABLE unit.variables.cage_image_size_width $steppe_cagesize_calc_width}
    {VARIABLE unit.variables.cage_image_size_height $steppe_cagesize_calc_height}

    [unstore_unit]
        variable=unit
#ifdef OGRE_RUSSIAN
        text="Взят в плен!"
#else
        text="Captured!"
#endif
        red=255
        green=126
        blue=0
        find_vacant=no
    [/unstore_unit]

    [unit_overlay]
        x,y=$x1,$y1
        image="items/cage.png~SCALE($unit.variables.cage_image_size_width|,$unit.variables.cage_image_size_height|)"
    [/unit_overlay]
    [object]
        silent=yes
#        duration=scenario
        [filter]
            find_in=unit
        [/filter]
        [effect]
            apply_to=attack
            [set_specials]
                mode=append
                {WEAPON_SPECIAL_STEPPE_DEFENSE_ONLY2}
            [/set_specials]
        [/effect]
        [effect]
            apply_to=zoc
            value=no
        [/effect]
        [effect]
            apply_to=new_ability
            [abilities]
              [dummy]
                 id=steppe_captured
              [/dummy]
            [/abilities]
        [/effect]   
#        {STEPPE_DEFENSE_MPCOST_CHANGE 20 90}
        {STEPPE_DEFENSE_MPCOST_CHANGE 10 90}
    [/object]
    [set_variables]
        name=capture_unit_information
        mode=append
        [value]
            id=$unit.id
#            side=$unit.side
#            turn_of_selling=$"($turn_number| + 3)"
#            turn_of_selling=$"($turn_number| + 2)"
            turn_of_selling=$"($turn_number| + 1)"
            seller_side=$second_unit.side
            seller_id=$second_unit.id
        [/value]
    [/set_variables]
               [if]
                   [variable]
                       name=knockback_target_hex.length
                       greater_than=0
                   [/variable]
   
                   [then]
                        [teleport]
                            [filter]
                                x,y=$x1,$y1
                            [/filter]
                            animate=no#yes
                            
                            x,y=$knockback_target_hex.x,$knockback_target_hex.y
                           check_passability=yes
                           clear_shroud=yes
                        [/teleport]
                        [redraw]
                        [/redraw]
#                       [if]
#                           [have_unit]
#                               x,y=$knockback_target_hex.x,$knockback_target_hex.y
#                           [/have_unit]
#   
#                           [then]
#                               [fire_event]
#                                      name=moveto
#                                      [primary_unit]
#                                           x,y=$knockback_target_hex.x,$knockback_target_hex.y
#                                      [/primary_unit]
#                               [/fire_event]
#                           [/then]
#                       [/if]
                   [/then]
               [/if]
   
               {CLEAR_VARIABLE knockback_direction,knockback_target_hex}
[/event]
[event]
    name=moveto
    id=steppe_freeunit_event
    first_time_only=no
    [filter]
    [filter_location]
            [filter]
            ability=steppe_captured
            [filter_side]
            [allied_with]
                side=$unit.side
            [/allied_with]
            [/filter_side]
            [/filter]
            radius=1
    [/filter_location]
    [/filter]
    [store_unit]
        [filter]
            ability=steppe_captured
            [filter_side]
            [allied_with]
                side=$unit.side
            [/allied_with]
            [/filter_side]
        [filter_location]
            x,y=$x1,$y1
            radius=1
        [/filter_location]
        [/filter]
        variable=steppe_freedunit
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=steppe_freedunit.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH steppe_freedunit i}

    {VARIABLE freer_points 0}
    {VARIABLE capturer_points 0}

    {STEPPE_CAGE_LEVELCALC steppe_freedunit[$i] $steppe_freedunit[$i].x $steppe_freedunit[$i].y}

    {IF_VAR freer_points greater_than $capturer_points (
    [then]

    {VARIABLE prisoner_tofree yes}
    {STEPPE_FREEUNIT $steppe_freedunit[$i].x $steppe_freedunit[$i].y}
    [/then]
    [else]
#this is so even lvl0s can free units when there are no enemies nearby
    {IF_VAR capturer_points less_than 1 (
    [then]

    {VARIABLE prisoner_tofree yes}
    {STEPPE_FREEUNIT $steppe_freedunit[$i].x $steppe_freedunit[$i].y}
    [/then]
    [else]
    {VARIABLE prisoner_tofree no}
    [/else]
    )}

    [/else]
    )}
    
    [if]
    {VARIABLE_CONDITIONAL prisoner_tofree not_equals yes}
    [then]
    [sound]
      name=mace-miss.ogg
    [/sound]
    [unstore_unit]
        variable=steppe_freedunit[$i]
#ifdef OGRE_RUSSIAN
        text=_"Недостаточно юнитов
         чтобы освободить!"
#else
        text=_"Not enough units
         to free!"
#endif
        red=255
        green=128
        blue=0        
        find_vacant=no
    [/unstore_unit]
    [/then]
    [/if]

#    [chat]
#       speaker=_"Debug"
#       message= _ "Freer points: $freer_points|. Slaver points: $capturer_points|. Prisoner free: $prisoner_tofree|"
#    [/chat]
    {CLEAR_VARIABLE freer_points}
    {CLEAR_VARIABLE capturer_points}
    {CLEAR_VARIABLE prisoner_tofree}
    [delay]
       time=100
    [/delay]
    {NEXT i}
    {CLEAR_VARIABLE steppe_freedunit}
    [/then]
    [/if]
[/event]
[event]
    name=side turn
    id=steppe_capture_autosell_event
    first_time_only=no

    {FOREACH capture_unit_information i}
        [if]
            [variable]
                name=capture_unit_information[$i].turn_of_selling
                less_than_equal_to=$turn_number
            [/variable]
            [and]
                [variable]
                    name=capture_unit_information[$i].seller_side
                    equals=$side_number
                [/variable]
            [/and]
            [then]

    #check if there are more freers than sellers next to the cage when trying to sell
    [store_unit]
        [filter]
        [filter_side]
        [allied_with]
            side=$capture_unit_information[$i].seller_side
        [/allied_with]
        [/filter_side]
        [filter_location]
        [filter]
            id=$capture_unit_information[$i].id
        [/filter]
        radius=1
        [/filter_location]
        [not]
            ability=steppe_captured
            [or]
                [filter_wml]
                [status]
                    petrified=yes
                [/status]
                [/filter_wml]
            [/or]
        [/not]
        [/filter]
        variable=tmp_steppe_sellers
        kill=no
    [/store_unit]
    [store_unit]
        [filter]
        [filter_side]
        [enemy_of]
            side=$capture_unit_information[$i].seller_side
        [/enemy_of]
        [/filter_side]
        [filter_location]
        [filter]
            id=$capture_unit_information[$i].id
        [/filter]
        radius=1
        [/filter_location]
        [not]
            ability=steppe_captured
            [or]
                [filter_wml]
                [status]
                    petrified=yes
                [/status]
                [/filter_wml]
            [/or]
        [/not]
        [/filter]
        variable=tmp_steppe_freers
        kill=no
    [/store_unit]

    [if]
    {VARIABLE_CONDITIONAL tmp_steppe_sellers.length greater_than $tmp_steppe_freers.length}
    [or]
    {VARIABLE_CONDITIONAL tmp_steppe_freers.length less_than 1} #second check just in case there are no sellers or freers nearby
    [/or]
    [else]

    [store_unit]
        [filter]
            id=$capture_unit_information[$i].id
        [/filter]
        variable=steppe_soldunit
        kill=no
    [/store_unit]
        [unstore_unit]
            variable=steppe_soldunit
#ifdef OGRE_RUSSIAN
            text=_"Слишком много врагов возле
            клетки чтобы продать!"
#else
            text=_"Too many enemies next
            to the cage to sell!"
#endif
            red=255
            green=128
            blue=0        
            find_vacant=no
        [/unstore_unit]
        {CLEAR_VARIABLE steppe_soldunit}
        [/else]
        [then]


            [if]
                [have_unit]
                    id=$capture_unit_information[$i].id
                    ability=steppe_captured
                [/have_unit]
                [then]
    [store_unit]
        [filter]
            id=$capture_unit_information[$i].id
        [/filter]
        variable=steppe_soldunit
        kill=no
    [/store_unit]
        [store_unit_type]
            type=$steppe_soldunit.type
            variable=captureunittype
        [/store_unit_type]
#        {VARIABLE capturegold "$($captureunittype.cost| * 1.33)"}
        {VARIABLE capturegold "$($captureunittype.cost| * 1.25)"}
        {VARIABLE_OP capturegold round ceil}

    [if]
    #check if any units from the capturer's side still exist
        [have_unit]
            side=$capture_unit_information[$i].seller_side
        [/have_unit]
        [then]
    [gold]
        side=$capture_unit_information[$i].seller_side
        amount=$capturegold
    [/gold]
    [sound]
      name=gold.ogg
    [/sound]

        [unstore_unit]
            variable=steppe_soldunit
#ifdef OGRE_RUSSIAN
            text="$capturegold| золота"
#else
            text="$capturegold|g"
#endif
            red=255
            green=255
            blue=0
            find_vacant=no
        [/unstore_unit]

        [/then]
        [else]
        [/else]
    [/if]

[if]
#check if the capturer still exists
    [have_unit]
        id=$capture_unit_information[$i].seller_id
    [/have_unit]
    [then]
#give the capturer exp
    {EXP_VALUE_CALC $capture_unit_information[$i].id steppe_captured_exp}
    [store_unit]
        [filter]
            id=$capture_unit_information[$i].seller_id
        [/filter]
        variable=capturer_exp
        kill=no
    [/store_unit]
    {VARIABLE_OP capturer_exp.experience add $steppe_captured_exp}
    [unstore_unit]
        variable=capturer_exp
        find_vacant=no
        advance=yes
        fire_event=yes#fires any advance/post advance events
    [/unstore_unit]
    {CLEAR_VARIABLE capturer_exp}
    {CLEAR_VARIABLE steppe_captured_exp}
    [/then]
[/if]

    [object]
        silent=yes
        duration=scenario
        [filter]
            id=$capture_unit_information[$i].id
        [/filter]
        [effect]
            apply_to=new_ability
            [abilities]
              [dummy]
                 id=steppe_notrigger_onkill_abilities #dummy ability used for disabling on
              [/dummy]
            [/abilities]
        [/effect]   
    [/object]

[if]
#check if the capturer still exists
    [have_unit]
        id=$capture_unit_information[$i].seller_id
    [/have_unit]
    [then]
        [kill]
            id=$capture_unit_information[$i].id
            animate=no
            fire_event=yes
        [secondary_unit]
            id=$capture_unit_information[$i].seller_id
        [/secondary_unit]
        [/kill]
    [/then]
    [else]
    [if]
    #check if any units from the capturer's side still exist
        [have_unit]
            side=$capture_unit_information[$i].seller_side
        [/have_unit]
        [then]
        [kill]
            id=$capture_unit_information[$i].id
            animate=no
            fire_event=yes
        [secondary_unit]
            side=$capture_unit_information[$i].seller_side
        [/secondary_unit]
        [/kill]
        [/then]
        [else]
        {STEPPE_FREEUNIT $steppe_soldunit.x $steppe_soldunit.y}
        [/else]
    [/if]
    [/else]
[/if]
#        {CLEAR_VARIABLE capturedunittype}
#        {CLEAR_VARIABLE capturedgold}
        {CLEAR_VARIABLE steppe_soldunit}


#                {MODIFY_UNIT id=$capture_unit_information[$i].id status.slowed yes}


                [clear_variable]
                    name=capture_unit_information[$i]
                [/clear_variable]
                [/then]
                [else]
                #if the unit is freed, remove the variables
                {CLEAR_VARIABLE capture_unit_information[$i]}
                [/else]
            [/if]
            [/then]
        [/if]

            [/then]
        [/if]
    {CLEAR_VARIABLE tmp_steppe_sellers}
    {CLEAR_VARIABLE tmp_steppe_freers}
    {NEXT i}
[/event]

[event]
    name=victory
    id=steppe_capture_victory_event
    first_time_only=no

    {CLEAR_VARIABLE capture_unit_information}
[/event]
    [+attack]
    [+specials]
#enddef

#define ABILITY_OGRE_BODYGUARD
    #used by the Ogre Bodyguard unit
    [resistance]
        id=steppe_ogre_bodyguard
        add=10
        max_value=30
        apply_to=blade,pierce,impact,fire,cold,arcane
        {TRANSLATE_ABILITY _"bodyguard" _"телохранитель"}
        {TRANSLATE_DESCRIPTION _"If standing next to either a Ogre Mancatcher, Ogre Slaver Apprentice or Ogre Slaver, this unit deals 20% more damage, and the other units(s) gain a 10% bonus to all resistances (up to 30%." _"Если телохранитель стоит возле Людолова, Подмастерья работорговца, или Работорговца, то его урон увеличивается на 20%, а охраняемые юниты получают 10% бонус сопротивления ко всем типам урона (30% максимум)."}
        affect_self=no
        affect_allies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
        [filter]
            ability=steppe_ogre_bodyguarded
        [/filter]
        [/affect_adjacent]
        [filter_base_value]
            less_than=30
        [/filter_base_value]
    [/resistance]
#enddef

#define ABILITY_OGRE_BODYGUARDED
    #used by the mancatcher/slaver apprentice/slaver
    #invisible ability used both as a filter, and as a 20% damage buff to the bodyguard (as I couldn't code an adjacent filter properly)
    [leadership]
        id=steppe_ogre_bodyguarded
        value=20
        cumulative=no
        affect_self=no
        affect_allies=yes
        [affect_adjacent]
            [filter]
                ability=steppe_ogre_bodyguard
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef

#define ABILITY_DEPLETING NUMBER
    [dummy]
        id=depleting{NUMBER}
        {TRANSLATE_ABILITY "depleting -"+{NUMBER} "истощается -"+{NUMBER}}
        {TRANSLATE_DESCRIPTION _"This unit loses "+{NUMBER}+_" hp each turn. Like poison, this ability cannot kill the unit." _"Этот юнит теряет "+{NUMBER}+_" здоровья каждый ход. Так же, как и от действия яда, юнит не может погибнуть от действия истощения."}
    [/dummy]

     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=side turn
    id=steppe_depleting{NUMBER}_event
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=depleting{NUMBER}
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=depleting
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=depleting.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH depleting i}


        [harm_unit]
            [filter]
                id=$depleting[$i].id
            [/filter]
            amount={NUMBER}
            experience=no
            fire_event=yes
            animate=no
            kill=no
        [/harm_unit] 
    [delay]
       time=100
    [/delay]
    {NEXT i}
    {CLEAR_VARIABLE depleting}
    [/then]
    [/if]
    [/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef

#define ABILITY_THUNDERSTRIKE NUMBER
    [dummy]
        id=thunderstrike{NUMBER}
        {TRANSLATE_ABILITY "thunderstrike "+{NUMBER} "удар молнией "+{NUMBER}}
        {TRANSLATE_DESCRIPTION _"Each turn, this unit attacks a random adjacent enemy with lightning, dealing "+{NUMBER}+_" fire damage." _"В начале каждого хода молния бьёт одного из стоящих рядом врагов, нанося "+{NUMBER}+_" огненного урона. Удар молнией может добить противника."} 
    [/dummy]

     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=side turn
    id=steppe_thunderstrike{NUMBER}
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=thunderstrike{NUMBER}
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=thundershaman
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=thundershaman.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH thundershaman e}
    [store_unit]
        [filter]
            [filter_adjacent]
                x,y=$thundershaman[$e].x,$thundershaman[$e].y
            [/filter_adjacent]
            [filter_side]
                [enemy_of]
                    side=$side_number
                [/enemy_of]
            [/filter_side]
            [not]
            [filter_wml]
            [status]
                petrified=yes
            [/status]
            [/filter_wml]
            [/not]
        [/filter]
        variable=thundertarget
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=thundertarget.length
        greater_than=0
    [/variable]
    [then]
    {VARIABLE thundertarget_random_limit $thundertarget.length}
    {VARIABLE_OP thundertarget_random_limit sub 1}
    {RANDOM 0..$thundertarget_random_limit}

#since the array number is offset by one from the length (if there are 2 units, the length is 2, but the units are [0] and [1])

    [animate_unit]
        flag=attack
        [filter]
            id=$thundershaman[$e].id
        [/filter]
        [filter_second]
            id=$thundertarget[$random].id
        [/filter_second]
        [primary_attack]
            name=lightning
        [/primary_attack]
        [facing]
            x,y=$thundertarget[$random].x,$thundertarget[$random].y
        [/facing]
        hits=yes
    [/animate_unit]
#    [chat]
#        message=_"target: $thundertarget[$random].id, facing: $thundershaman[$e].facing, random $random, length: $thundertarget.length"
#    [/chat]
    [harm_unit]
        [filter]
            id=$thundertarget[$random].id
        [/filter]
        [filter_second]
            id=$thundershaman[$e].id
        [/filter_second]
        amount={NUMBER}
#        alignment=$thundershaman[$e].alignment
        damage_type=fire
        experience=yes
        fire_event=yes
        animate=yes
    [/harm_unit] 
    [/then]
    [/if]
    {NEXT e}
    {CLEAR_VARIABLE thundershaman}
    {CLEAR_VARIABLE thundertarget}
    {CLEAR_VARIABLE thundertarget_random_limit}
    [/then]
    [/if]
    [/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef


#define ABILITY_LIFESTEAL_AURA NUMBER
    [dummy]
        id=lifesteal_aura{NUMBER}
        {TRANSLATE_ABILITY "lifesteal aura "+{NUMBER} "аура высасывания "+{NUMBER}}
        {TRANSLATE_DESCRIPTION _"Each turn, this unit deals "+{NUMBER}+" damage to adjacent living enemies, and heals self by "+{NUMBER}+_" HP for each enemy damaged. Like poison, this can't kill." _"Каждый ход юнит наносит "+{NUMBER}+" урона стоящим рядом живым врагам, и лечит себя на "+{NUMBER}+_" ЗД за каждого поврежденного врага. Как яд, эта способность не может убить врага."} 
    [/dummy]

     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=side turn
    id=steppe_lifesteal_aura{NUMBER}
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=lifesteal_aura{NUMBER}
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=lifestealer
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=lifestealer.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH lifestealer e}
    [store_unit]
        [filter]
            [filter_adjacent]
                x,y=$lifestealer[$e].x,$lifestealer[$e].y
            [/filter_adjacent]
            [filter_side]
                [enemy_of]
                    side=$side_number
                [/enemy_of]
            [/filter_side]
            [not]
            [filter_wml]
            [status]
                petrified=yes
            [/status]
            [or]
            [status]
                undrainable=yes
            [/status]
            [/or]
            [/filter_wml]
            [/not]
        [/filter]
        variable=lifesteal_target
        kill=no
    [/store_unit]

    {VARIABLE tmp_lifesteal_heal 0}

    [if]
    [variable]
        name=lifesteal_target.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH lifesteal_target l}

#since the array number is offset by one from the length (if there are 2 units, the length is 2, but the units are [0] and [1])

    [animate_unit]
        flag=drain_anim
        [filter]
            id=$lifestealer[$e].id
        [/filter]
        [facing]
            x,y=$lifesteal_target[$l].x,$lifesteal_target[$l].y
        [/facing]
        hits=yes
    [/animate_unit]
#    [chat]
#        message=_"target: $lifesteal_target[$random].id, facing: $lifestealer[$e].facing, random $random, length: $lifesteal_target.length"
#    [/chat]
    [harm_unit]
        [filter]
            id=$lifesteal_target[$l].id
        [/filter]
        [filter_second]
            id=$lifestealer[$e].id
        [/filter_second]
        amount={NUMBER}
#        alignment=$lifestealer[$e].alignment
#        damage_type=fire
        experience=yes
        fire_event=yes
        animate=yes
        experience=no
        kill=no
    [/harm_unit]
    {VARIABLE_OP tmp_lifesteal_heal add {NUMBER}}

    {NEXT l}
    [/then]
    [/if]

        [heal_unit]
            [filter]
                id=$lifestealer[$e].id
            [/filter]
            amount=$tmp_lifesteal_heal
            animate=yes
            restore_statuses=no
        [/heal_unit]

    {NEXT e}
    {CLEAR_VARIABLE lifestealer}
    {CLEAR_VARIABLE lifesteal_target}
    {CLEAR_VARIABLE tmp_lifesteal_heal}
    [/then]
    [/if]
    [/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef
