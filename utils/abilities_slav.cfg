#textdomain wesnoth-units

#define ABILITY_SLAVFACTION
    [dummy]
        id=slavfaction
    [/dummy]
#enddef

#define ABILITY_SLAV_KRAD
    [dummy]
        id=slav_krad
    [/dummy]
#enddef

#define ABILITY_SLAV_TEMSK
    [dummy]
        id=slav_temsk
    [/dummy]
#enddef

#define ABILITY_SLAV_NOVGOROD
    [dummy]
        id=slav_novgorod
    [/dummy]
#enddef


#define ABILITY_STEPPE_SWAMPSTALK
    [hides]
        id=steppe_swampstalk
        {TRANSLATE_ABILITY_HIDES _"swampstalk" "болотная засада"}
        {TRANSLATE_DESCRIPTION _"This unit is invisible on swamp terrain." _"Этот юнит невидимый на болотной местности."}
        affect_self=yes
        [filter]
            [filter_location]
                terrain=Ss^*,St^*,Sm^*
            [/filter_location]
        [/filter]
    [/hides]
#enddef

#define STEPPE_ADAPTIVEARMOR_EVENT ID TYPE RUSTYPE VALUE

#changes a resistance to the type by {VALUE}% for a turn
[event]
    name=attacker_hits
    id={ID}
    first_time_only=no

    [filter_attack]
        type={TYPE}
    [/filter_attack]

    [filter_second]
        ability=steppe_adaptive_armor
    [/filter_second]

    {VARIABLE tmp_textvalue {VALUE}}
    {VARIABLE_OP tmp_textvalue multiply -1}

    [store_unit]
        [filter]
            id=$second_unit.id
        [/filter]
        variable=steppe_adaptivearmorunit
        kill=no
    [/store_unit]

    {IF_VAR steppe_adaptivearmorunit.variables.adaptive_armor_stacks greater_than_equal_to 1 (
    [else]
    {VARIABLE steppe_adaptivearmorunit.variables.adaptive_armor_stacks 0}
    [/else]
    )}

    {VARIABLE_OP steppe_adaptivearmorunit.variables.adaptive_armor_stacks add 1}

    [unstore_unit]
        variable=steppe_adaptivearmorunit
#ifdef OGRE_RUSSIAN
        text="+$tmp_textvalue|% {RUSTYPE}"
#else
        text="+$tmp_textvalue|% {TYPE}"
#endif
        find_vacant=no
    [/unstore_unit]
#    [chat]
#        message=$second_unit.variables.adaptive_armor_stacks
#    [/chat]


#check if the unit already has adaptive armor variables for that turn, and if so just add the number instead of making a seperate array entry, to reduce bugs
    [if]
    {VARIABLE_CONDITIONAL adaptive_armor_stacks_sub_information.length greater_than 0}
    [then]
    {FOREACH adaptive_armor_stacks_sub_information x}
    {IF_VAR adaptive_armor_stacks_sub_information[$x].id equals $second_unit.id (
    [and]
    {VARIABLE_CONDITIONAL adaptive_armor_stacks_sub_information[$x].turn_of_reducing equals $"($turn_number| + 0)"}
    [/and]
    [then]
    {VARIABLE tmp_adaptive_armor_unit_found yes}
    {VARIABLE_OP adaptive_armor_stacks_sub_information[$x].reduce_by add 1}
    [/then]
    [else]
    [/else]
    )}
    {NEXT x}
    [/then]
    [else]
    {VARIABLE tmp_adaptive_armor_unit_found no}
    [/else]
    [/if]

    {IF_VAR tmp_adaptive_armor_unit_found not_equals yes (
    [then]
    [set_variables]
        name=adaptive_armor_stacks_sub_information
        mode=append
        [value]
            id=$second_unit.id
            side=$second_unit.side
            reduce_by=1
            turn_of_reducing=$"($turn_number| + 0)"
        [/value]
    [/set_variables]
    [/then])}
    {CLEAR_VARIABLE tmp_adaptive_armor_unit_found}

    {CLEAR_VARIABLE tmp_textvalue}
    {CLEAR_VARIABLE steppe_adaptivearmorunit}

    [object]
        silent=yes
        duration=turn end

        [filter]
            x,y=$x2,$y2
        [/filter]

        [effect]
            apply_to=resistance
            replace=no
            [resistance]
                {TYPE}={VALUE}
            [/resistance]
        [/effect]
    [/object]

    [fire_event]
        name=steppe_customevent_adaptivearmor
        [primary_unit]
            id=$second_unit.id
        [/primary_unit]
    [/fire_event]
[/event]

#TODO: fix the defender event not working for some reason

[event]
    name=defender_hits
    id={ID}_defense
    first_time_only=no

    [filter_second_attack]
        type={TYPE}
    [/filter_second_attack]

    [filter]
        ability=steppe_adaptive_armor
    [/filter]

    {VARIABLE tmp_textvalue {VALUE}}
    {VARIABLE_OP tmp_textvalue multiply -1}

    [store_unit]
        [filter]
            id=$unit.id
        [/filter]
        variable=steppe_adaptivearmorunit
        kill=no
    [/store_unit]

    {IF_VAR steppe_adaptivearmorunit.variables.adaptive_armor_stacks greater_than_equal_to 1 (
    [else]
    {VARIABLE steppe_adaptivearmorunit.variables.adaptive_armor_stacks 0}
    [/else]
    )}

    {VARIABLE_OP steppe_adaptivearmorunit.variables.adaptive_armor_stacks add 1}

    [unstore_unit]
        variable=steppe_adaptivearmorunit
#ifdef OGRE_RUSSIAN
        text="+$tmp_textvalue|% {RUSTYPE}"
#else
        text="+$tmp_textvalue|% {TYPE}"
#endif
        find_vacant=no
    [/unstore_unit]
#    [chat]
#        message=$unit.variables.adaptive_armor_stacks
#    [/chat]

#check if the unit already has adaptive armor variables for that turn, and if so just add the number instead of making a seperate array entry, to reduce bugs
    [if]
    {VARIABLE_CONDITIONAL adaptive_armor_stacks_sub_information.length greater_than 0}
    [then]
    {FOREACH adaptive_armor_stacks_sub_information x}
    {IF_VAR adaptive_armor_stacks_sub_information[$x].id equals $unit.id (
    [and]
    {VARIABLE_CONDITIONAL adaptive_armor_stacks_sub_information[$x].turn_of_reducing equals $"($turn_number| + 0)"}
    [/and]
    [then]
    {VARIABLE tmp_adaptive_armor_unit_found yes}
    {VARIABLE_OP adaptive_armor_stacks_sub_information[$x].reduce_by add 1}
    [/then]
    [else]
    [/else]
    )}
    {NEXT x}
    [/then]
    [else]
    {VARIABLE tmp_adaptive_armor_unit_found no}
    [/else]
    [/if]

    {IF_VAR tmp_adaptive_armor_unit_found not_equals yes (
    [then]
    [set_variables]
        name=adaptive_armor_stacks_sub_information
        mode=append
        [value]
            id=$unit.id
            side=$unit.side
            reduce_by=1
            turn_of_reducing=$"($turn_number| + 0)"
        [/value]
    [/set_variables]
    [/then])}
    {CLEAR_VARIABLE tmp_adaptive_armor_unit_found}


    {CLEAR_VARIABLE tmp_textvalue}
    {CLEAR_VARIABLE steppe_adaptivearmorunit}

    [object]
        silent=yes
        duration=turn end

        [filter]
            x,y=$x1,$y1
        [/filter]

        [effect]
            apply_to=resistance
            replace=no
            [resistance]
                {TYPE}=-5
            [/resistance]
        [/effect]
    [/object]

    [fire_event]
        name=steppe_customevent_adaptivearmor
        [primary_unit]
            id=$unit.id
        [/primary_unit]
    [/fire_event]
[/event]

[event]
    name=side turn end
    id=steppe_adaptive_armor_stacks_event
    first_time_only=no

    {FOREACH adaptive_armor_stacks_sub_information i}
#    [chat]
#        message=_"id: $adaptive_armor_stacks_sub_information[$i].id| side: $adaptive_armor_stacks_sub_information[$i].side| turn: $adaptive_armor_stacks_sub_information[$i].turn_of_reducing| reduce by: $adaptive_armor_stacks_sub_information[$i].reduce_by|"
#    [/chat]
        [if]
            [variable]
                name=adaptive_armor_stacks_sub_information[$i].turn_of_reducing
                less_than_equal_to=$turn_number
            [/variable]
            [else]
#                [chat]
#                    message="not the right turn yet"
#                [/chat]
            [/else]
            [then]

            [if]
                [variable]
                    name=adaptive_armor_stacks_sub_information[$i].side
                    equals=$side_number
                [/variable]
            [else]
#                [chat]
#                    message="not the right side yet"
#                [/chat]
            [/else]
            [then]
            [if]
            [have_unit]
                    id=$adaptive_armor_stacks_sub_information[$i].id
            [/have_unit]
            [then]
                [store_unit]
                    [filter]
                        id=$adaptive_armor_stacks_sub_information[$i].id
                    [/filter]
                    variable=steppe_adaptivearmorunit
                    kill=no
                [/store_unit]                
                {VARIABLE_OP steppe_adaptivearmorunit.variables.adaptive_armor_stacks sub $adaptive_armor_stacks_sub_information[$i].reduce_by}
                [unstore_unit]
                    variable=steppe_adaptivearmorunit
                    find_vacant=no
                [/unstore_unit]
#                [chat]
#                    message=$steppe_adaptivearmorunit.variables.adaptive_armor_stacks
#                [/chat]
                [clear_variable]
                    name=adaptive_armor_stacks_sub_information[$i]
                [/clear_variable]
                {CLEAR_VARIABLE steppe_adaptivearmorunit}
            [/then]
            [else]
#            [chat]
#                message=_"adaptive armor unit not found"
#            [/chat]
            [/else]
            [/if]
            [/then]
        [/if]
            [/then]
        [/if]
    {NEXT i}
[/event]
#enddef

#define ABILITY_STEPPE_ADAPTIVE_ARMOR
    [adaptive_armor]
        id=steppe_adaptive_armor
        {TRANSLATE_ABILITY "adaptive armor" "адаптивная броня"}
        {TRANSLATE_DESCRIPTION  _"Whenever this unit gets hit, they gain +5% resistance to the damage type they were hit with until the end of their next turn." _"За каждый удар этот боец получает +5% сопротивляемости к тому типу урона, которым его ударили, до конца своего следующего хода. "}
    [/adaptive_armor]
     # wmlxgettext: [abilities]
[/abilities]
{STEPPE_ADAPTIVEARMOR_EVENT steppe_adaptivearmor_event_blade blade режущий -5}
{STEPPE_ADAPTIVEARMOR_EVENT steppe_adaptivearmor_event_pierce pierce колющий -5}
{STEPPE_ADAPTIVEARMOR_EVENT steppe_adaptivearmor_event_impact impact крушащий -5}
{STEPPE_ADAPTIVEARMOR_EVENT steppe_adaptivearmor_event_fire fire огонь -5}
{STEPPE_ADAPTIVEARMOR_EVENT steppe_adaptivearmor_event_cold cold холод -5}
{STEPPE_ADAPTIVEARMOR_EVENT steppe_adaptivearmor_event_arcane arcane мистика -5}
[+abilities]
#enddef

#ability idea: brittle armor: like adaptive armor, but in reverse (each hit lowers the resistance further)


#define ABILITY_STEPPE_RAVENFORM TYPE SPECIES
    [ravenform]
        id=steppe_ravenform
        {TRANSLATE_ABILITY "raven form" "форма ворона"}
        {TRANSLATE_DESCRIPTION  _"With a rightclick menu, you can transform this unit into a raven. In raven form, you can use the same menu to transform back. A unit can only transform once per turn. AI can use this ability too." _"Этот боец может превратиться в ворона через меню, которое можно вызвать, кликнув по нему правой кнопкой мыши. Так же он может превратиться обратно в человека. Превращаться можно только 1 раз за ход. ИИ использует эту способность автоматически. "}
        transform_into={TYPE}
        species={SPECIES}
    [/ravenform]
#enddef

#define STEPPE_SLAV_TRANSFORM_MENU ID TEXT RUSTEXT FILTER
    [set_menu_item]
        id=steppe_raven_menu{ID}
#ifdef OGRE_RUSSIAN
        description={RUSTEXT}
#else
        description={TEXT}
#endif
        image=attacks/beak.png~SCALE(20,20)
        [show_if]
#        {VARIABLE_CONDITIONAL steppe_disable_calculator_menu not_equals yes}
        [/show_if]

        [filter_location]
            [filter]
                    {FILTER}
                    side=$side_number
                    [not]
                       ability=steppe_raven_alreadytransformed
                    [/not]
            [/filter]
        [/filter_location]
        [command]

        [fire_event]
            name=steppe_customevent_ravenform
            [primary_unit]
                x,y=$x1,$y1
            [/primary_unit]
        [/fire_event]

        [/command]
    [/set_menu_item]
#enddef

#define EVENTLOADER_EVENTS_SLAV
[event]
    name=start
    id=steppe_raven_menu
    first_time_only=no
    {STEPPE_SLAV_TRANSFORM_MENU human_to_raven "transform into a raven" "превратится в ворона" (
    ability=steppe_ravenform
    [not]
        race=steppe_raven
    [/not]
    )}
    {STEPPE_SLAV_TRANSFORM_MENU raven_to_human "return to human form" "вернутся в человеческую форму" (
    ability=steppe_ravenform
    race=steppe_raven
    )}

#ifdef STEPPE_ERROR
    [chat]
        message="Error: failed to load test factions" #dummy error
    [/chat]
#endif
[/event]
[event]
    name=steppe_customevent_ravenform
    id=steppe_ravenform_event
    first_time_only=no

    [if]
    [have_unit]
        x,y=$x1,$y1
        [not]
           ability=steppe_raven_alreadytransformed
        [/not]
    [/have_unit]
    [then]

        [store_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
            variable=steppe_raven_transform_unit
            kill=no
        [/store_unit]

#        [chat]
#            message=$steppe_raven_transform_unit.abilities.ravenform.transform_into
#        [/chat]

        {VARIABLE hpratio $steppe_raven_transform_unit.hitpoints}
        {VARIABLE_OP hpratio divide $steppe_raven_transform_unit.max_hitpoints}
        {VARIABLE mpratio $steppe_raven_transform_unit.moves}
        {VARIABLE_OP mpratio divide $steppe_raven_transform_unit.max_moves}

        [animate_unit]
            flag=transform
            [filter]
                x,y=$x1,$y1
            [/filter]
        [/animate_unit]
        {TRANSFORM_UNIT x,y=$x1,$y1 $steppe_raven_transform_unit.abilities.ravenform.transform_into}
#redraws the fog
        [redraw]
           clear_shroud=yes
        [/redraw]
        {CLEAR_VARIABLE steppe_raven_transform_unit}

        [store_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
    
            variable=steppe_raven_transform_unit
            kill=no
        [/store_unit]

        {VARIABLE steppe_raven_transform_unit.hitpoints $steppe_raven_transform_unit.max_hitpoints}
        {VARIABLE_OP steppe_raven_transform_unit.hitpoints multiply $hpratio}
        {VARIABLE steppe_raven_transform_unit.moves $steppe_raven_transform_unit.max_moves}
        {VARIABLE_OP steppe_raven_transform_unit.moves multiply $mpratio}

        [unstore_unit]
            variable=steppe_raven_transform_unit
            find_vacant=no
        [/unstore_unit]


        {CLEAR_VARIABLE steppe_raven_transform_unit}

#dummy ability to prevent units from transforming more than once per turn

        [object]
            silent=yes
            duration=turn

            [filter]
                x,y=$x1,$y1
            [/filter]

            [effect]
                apply_to=new_ability
                [abilities]
                  [ravenform_transformed]
                     id=steppe_raven_alreadytransformed
                  [/ravenform_transformed]
                [/abilities]
            [/effect]
        [/object]
        [redraw]
           clear_shroud=yes
        [/redraw]
    [/then]
    [/if]
[/event]
[event]
name=unused#side turn 1
id=steppe_marketspawn_event
first_time_only=no
{IF_VAR steppe_disablebuildings not_equals yes (
[and]
[have_unit]
side=$side_number
ability=slavfaction
canrecruit=yes
[/have_unit]
[/and]
[then]
        [store_unit]
            [filter]
                side=$side_number
                canrecruit=yes
            [/filter]
            variable=sideleader
            kill=no
        [/store_unit]

        [if]
        [have_unit]
                ability=slav_temsk
                side=$side_number
                canrecruit=yes
        [/have_unit]
        [then]
        [/then]
        [/if]

        [if]
        [have_unit]
                ability=slav_novgorod
                side=$side_number
                canrecruit=yes
        [/have_unit]
        [then]
        {UNIT $side_number Slav_Marketplace $sideleader.x $sideleader.y ()}
        [store_unit]
            [filter]
                side=$side_number
                type=Slav_Marketplace
            [/filter]
            variable=steppe_market
            kill=no
        [/store_unit]
        [store_side]
            side=$side_number
            variable=steppe_marketside
        [/store_side]
#        {VARIABLE steppe_market.variables.income $steppe_marketside.village_gold}
#        {VARIABLE steppe_market.upkeep -$steppe_marketside.village_support}
        {VARIABLE_OP steppe_market.hitpoints add "$(20 * ($sideleader.level| -2 ))"}
        {VARIABLE_OP steppe_market.max_hitpoints add "$(20 * ($sideleader.level| -2 ))"}
        [unstore_unit]
            variable=steppe_market
            find_vacant=no
        [/unstore_unit]
        [/then]
        [/if]

        {CLEAR_VARIABLE sideleader}
        {CLEAR_VARIABLE steppe_market}
        {CLEAR_VARIABLE steppe_marketside}
[/then])}
[/event]
[event]
    name=victory
    id=steppe_clear_smith_buff_overlays
    first_time_only=no
    [store_unit]
        [filter]
            ability=steppe_smith_buff1
            [or]
                ability=steppe_smith_buff2
            [/or]
        [/filter]
        variable=smith_buffed
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=smith_buffed.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH smith_buffed i}
    {SMITH_CLEAR_OVERLAYS $smith_buffed[$i].id}
    {NEXT i}
    {CLEAR_VARIABLE smith_buffed}
    [/then]
    [/if]
    [/event]
#enddef

#define ABILITY_STEPPE_SURPRISE_ATTACK
    [dummy]
        id=steppe_surprise_attack
        {TRANSLATE_ABILITY "surprise attack" "внезапная атака"}
        {TRANSLATE_DESCRIPTION _"At the start of the turn, if this unit is invisibile, they gain marksman on ranged attacks for 1 turn." _"Если в начале хода юнит в засаде, он получает меткость на свои дальние атаки на один ход."}
    [/dummy]
     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=turn refresh #not side turn, so the effect triggers after a unit's hidden-ness is calculated
    id=steppe_surpriseattack_event
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_surprise_attack
            ability_type_active=hides
            [not]
              status=uncovered
            [/not]            
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=surpriseattacker
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=surpriseattacker.length
        greater_than=0
    [/variable]
    [then]
#    [chat]
#        message="surprise attackers filter passed"
#    [/chat]
    {FOREACH surpriseattacker i}

    [object]
        silent=yes
        duration=turn end
        [filter]
            id=$surpriseattacker[$i].id
        [/filter]
        [effect]
            apply_to=attack
            range=ranged
            [set_specials]
                mode=append
                {WEAPON_SPECIAL_MARKSMAN}
            [/set_specials]
        [/effect]
    [/object]
    {NEXT i}
    {CLEAR_VARIABLE surpriseattacker}
    [/then]
    [/if]
    [/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef

#define SMITH_CLEAR_OVERLAYS ID
    [remove_unit_overlay]
        id={ID}
        image="misc/overlay-smith-buff-1.png"
    [/remove_unit_overlay]
    [remove_unit_overlay]
        id={ID}
        image="misc/overlay-smith-buff-2.png"
    [/remove_unit_overlay]
#enddef

#define SMITH_ACTIONS ABILITY FILTER_ALLY EFFECT
    [store_unit]
        [filter]
            side=$side_number
            ability={ABILITY}
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=steppe_smith
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=steppe_smith.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH steppe_smith e}
    [if]
    [have_unit]
        [filter_adjacent]
            x,y=$steppe_smith[$e].x,$steppe_smith[$e].y
        [/filter_adjacent]
        [filter_side]
            [allied_with]
                side=$side_number
            [/allied_with]
        [/filter_side]
        {FILTER_ALLY}
        [not]
            ability=steppe_building
        [/not]
    [/have_unit]
    [then]
    [store_unit]
        [filter]
            [filter_adjacent]
                x,y=$steppe_smith[$e].x,$steppe_smith[$e].y
            [/filter_adjacent]
            [filter_side]
                [allied_with]
                    side=$side_number
                [/allied_with]
            [/filter_side]
            {FILTER_ALLY}
            [not]
                ability=steppe_building
            [/not]
        [/filter]
        variable=steppe_smithally
        kill=no
    [/store_unit]
    [/then]
    [else]
    [store_unit]
        [filter]
            [filter_adjacent]
                x,y=$steppe_smith[$e].x,$steppe_smith[$e].y
            [/filter_adjacent]
            [filter_side]
                [allied_with]
                    side=$side_number
                [/allied_with]
            [/filter_side]
            {FILTER_ALLY}
        [/filter]
        variable=steppe_smithally
        kill=no
    [/store_unit]
    [/else]
    [/if]

    [if]
    [variable]
        name=steppe_smithally.length
        greater_than=0
    [/variable]
    [then]
    {VARIABLE steppe_smithally_random_limit $steppe_smithally.length}
    {VARIABLE_OP steppe_smithally_random_limit sub 1}
    {RANDOM 0..$steppe_smithally_random_limit}

#since the array number is offset by one from the length (if there are 2 units, the length is 2, but the units are [0] and [1])

    [animate_unit]
        flag=smith
        [filter]
            id=$steppe_smith[$e].id
        [/filter]
        [filter_second]
            id=$steppe_smithally[$random].id
        [/filter_second]
        [facing]
            x,y=$steppe_smithally[$random].x,$steppe_smithally[$random].y
        [/facing]
    [/animate_unit]
#removes existing buff overlays, so new ones can be applied later

    {SMITH_CLEAR_OVERLAYS $steppe_smithally[$random].id}

    {EFFECT}

    {CLEAR_VARIABLE steppe_smithally}
    {CLEAR_VARIABLE steppe_smithally_random_limit}

    [/then]
    [/if]
    {NEXT e}
    {CLEAR_VARIABLE steppe_smith}
    [/then]
    [/if]
#enddef

#define ABILITY_STEPPE_SMITH
    [dummy]
        id=steppe_smith
        {TRANSLATE_ABILITY "smith" "кузнец"}
        {TRANSLATE_DESCRIPTION _"Each turn, this unit upgrades a random adjacent ally's armor, increasing their physical resistances by 10% for the rest of the battle, and giving the smith 1 experience. Does not work on units with the 'adaptive armor' ability, and can't upgrade the same unit more than once per battle. Prioritizes normal units over buildings." _"В начале каждого этот юнит улучшает броню случайного стоящего рядом союзника, увеличивая его физические сопротивления на 10% до конца боя, и получая за это 1 опыта. Не работает на юнитов с способностью 'адаптивная броня', и не может улучшать одного и того же юнита больше чем 1 раз за бой. В приоритете обычные юниты, а не здания."} 
    [/dummy]

     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=side turn
    id=steppe_smith
    first_time_only=no
    {SMITH_ACTIONS steppe_smith (
    [not]
        ability=steppe_adaptive_armor
        [or]
            ability=steppe_smith_buff1
        [/or]
        [or]
            ability=steppe_smith_buff2
        [/or]
    [/not]
    ) (
    {IF_VAR steppe_hunntext_russian_enabled equals yes (
    [then]
    [floating_text]
       x,y=$steppe_smithally[$random].x,$steppe_smithally[$random].y
       text="улучшена броня!"
    [/floating_text]
    [/then]
    [else]
    [floating_text]
       x,y=$steppe_smithally[$random].x,$steppe_smithally[$random].y
       text="upgraded armor!"
    [/floating_text]
    [/else])}

    [object]
        silent=yes
        duration=scenario
        id=steppe_smithbuff1
        take_only_once=no

        [filter]
            id=$steppe_smithally[$random].id
        [/filter]

        [effect]
            apply_to=resistance
            replace=no
            [resistance]
                blade=-10
                pierce=-10
                impact=-10
            [/resistance]
        [/effect]
        [effect]
            apply_to=new_ability
            [abilities]
              [dummy]
                 id=steppe_smith_buff1
                 {TRANSLATE_ABILITY _"upgraded armor" _"улучшенная броня"}
                 {TRANSLATE_DESCRIPTION _"This unit has +10% physical resistances until the end of the battle." _"Этот юнит имеет +10% к физическим сопротивлениям до конца боя."}
              [/dummy]
            [/abilities]
        [/effect]   
    [/object]
    [unit_overlay]
        id=$steppe_smithally[$random].id
        image="misc/overlay-smith-buff-1.png"
    [/unit_overlay]

    [modify_unit]
      [filter]
        id=$steppe_smith[$e].id
      [/filter]
      experience="$($steppe_smith[$e].experience| + 1)"
    [/modify_unit]

    )}
    [/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef

#define ABILITY_STEPPE_MASTER_SMITH
    [dummy]
        id=steppe_master_smith
        {TRANSLATE_ABILITY "master smith" "мастер-кузнец"}
        {TRANSLATE_DESCRIPTION _"Each turn, this unit upgrades a random adjacent ally's equipment, increasing their physical resistances by 15%, magical resistances by 10%, and damage by 1 for the rest of the battle, and giving the smith 2 experience. Does not work on units with the 'adaptive armor' ability, and can't upgrade the same unit more than once per battle. Replaces the buffs applied by a lower-level smith." _"В начале каждого этот юнит улучшает броню случайного стоящего рядом союзника, увеличивая его физические сопротивления на 15%, магические сопротивления на 10%, урон атак на 1 до конца боя, и получая за это 2 опыта. Не работает на юнитов с способностью 'адаптивная броня', и не может улучшать одного и того же юнита больше чем 1 раз за бой. Заменяет улучшения, наложенные кузнецом более низкого уровня."} 
    [/dummy]

     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=side turn
    id=steppe_master_smith
    first_time_only=no
    {SMITH_ACTIONS steppe_master_smith (
    [not]
        ability=steppe_adaptive_armor
        [or]
            ability=steppe_smith_buff2
        [/or]
    [/not]
    ) (
    {IF_VAR steppe_hunntext_russian_enabled equals yes (
    [then]
    [floating_text]
       x,y=$steppe_smithally[$random].x,$steppe_smithally[$random].y
       text="улучшено снаряжение!"
    [/floating_text]
    [/then]
    [else]
    [floating_text]
       x,y=$steppe_smithally[$random].x,$steppe_smithally[$random].y
       text="upgraded equipment!"
    [/floating_text]
    [/else])}

    [if]
    [have_unit]
        id=$steppe_smithally[$random].id
        ability=steppe_smith_buff1
    [/have_unit]
    [then]
#remove the buffs applied by a normal smith, as having the buffs stack would be extremely OP
    [object]
        silent=yes
        duration=scenario
        id=steppe_smithbuff1_removal
        take_only_once=no

        [filter]
            id=$steppe_smithally[$random].id
        [/filter]

        [effect]
            apply_to=resistance
            replace=no
            [resistance]
                blade=10
                pierce=10
                impact=10
            [/resistance]
        [/effect]
        [effect]
            apply_to=remove_ability
            [abilities]
              [dummy]
                 id=steppe_smith_buff1
              [/dummy]
            [/abilities]
        [/effect]   
    [/object]    
    [/then]
    [/if]
    [object]
        silent=yes
        duration=scenario
        id=steppe_smithbuff2
        take_only_once=no

        [filter]
            id=$steppe_smithally[$random].id
        [/filter]

        [effect]
            apply_to=resistance
            replace=no
            [resistance]
                arcane=-10
                fire=-10
                cold=-10
                blade=-15
                pierce=-15
                impact=-15
            [/resistance]
        [/effect]
        [effect]
            apply_to=new_ability
            [abilities]
              [dummy]
                 id=steppe_smith_buff2
                 {TRANSLATE_ABILITY _"upgraded equipment" _"улучшенное снаряжение"}
                 {TRANSLATE_DESCRIPTION _"This unit has +15% physical resistances, +10% magical resistances and +1 damage until the end of the battle." _"Этот юнит имеет +15% к физическим сопротивлениям, +10% к магическим сопротивлениям и +1 к урону до конца боя."}
              [/dummy]
            [/abilities]
        [/effect]   
        [effect]
            apply_to=attack
            increase_damage=1
        [/effect]
    [/object]
    [unit_overlay]
        id=$steppe_smithally[$random].id
        image="misc/overlay-smith-buff-2.png"
    [/unit_overlay]

    [modify_unit]
      [filter]
        id=$steppe_smith[$e].id
      [/filter]
      experience="$($steppe_smith[$e].experience| + 2)"
    [/modify_unit]

    )}
    [/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef

#define WEAPON_SPECIAL_STEPPE_ADAPTIVE_STRIKE VALUE
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    [dummy]
        id=steppe_adaptive_strike_{VALUE}
        {TRANSLATE_ABILITY_HIDES _"adaptive strike +{VALUE}" _"адаптивный щит +{VALUE}"}
        {TRANSLATE_DESCRIPTION _"This attack deals {VALUE} more damage for each point of adaptive armor currently active on the unit." _"Эта атака наносит на {VALUE} больше урона за каждую единицу адаптивной брони, активной на юните. "}
    [/dummy]

[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

[event]
    name=steppe_customevent_adaptivearmor
    id=steppe_adaptivestrike_{VALUE}
    first_time_only=no
    [filter]
    [/filter]
    [object]
        silent=yes
        duration=turn end
        [filter]
            id=$unit.id
        [/filter]
        [effect]
            apply_to=attack
            special=steppe_adaptive_strike_{VALUE}
            increase_damage={VALUE}
        [/effect]
    [/object]
[/event]

[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef

#define ABILITY_STEPPE_INSPIRE
    #basically like regular leadership, except only 15% per level
    [leadership]
        id=steppe_inspire
        value="(15 * (level - other.level + 1))"
        cumulative=no
        {TRANSLATE_ABILITY _"inspire" "вдохновляет"}
        {TRANSLATE_DESCRIPTION _"Adjacent allies deal more damage - 15% if the same level, 30% if one level lower, 45% if two levels lower, etc." _"Стоящие рядом союзники наносят больше урона - 15% если одинаковый уровень, 30% если на уровень ниже, 45% если на два уровня ниже и т.д."}
        affect_self=no
        [affect_adjacent]
            [filter]
                formula="level < other.level + 1"
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef

#define ABILITY_STEPPE_BRAVADO
    #basically like regular leadership, except only 15% per level
    [leadership]
        id=steppe_bravado
        value="(-15 * (level - other.level + 1))"
        cumulative=yes
        {TRANSLATE_ABILITY _"bravado" "бравада"}
        {TRANSLATE_DESCRIPTION _"Adjacent living enemies deal less damage - -15% if the same level, -30% if one level lower, -45% if two levels lower, etc." _"Стоящие рядом живые враги наносят меньше урона - -15% если одинаковый уровень, -30% если на уровень ниже, -45% если на два уровня ниже и т.д."}
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            [filter]
                formula="level < other.level + 1"
                [not]
                    {STEPPE_FEAREXEMPT}
                [/not]
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef


#define ABILITY_STEPPE_DUEL
    # Canned definition of the Feeding ability to be included in an
    # [abilities] clause.  Note: this is deliberately unbalanced WML,
    # in order to close the abilities clause then insert the event
    # then reopen the abilities clause.
    [duel]
        id=steppe_duel
        {TRANSLATE_ABILITY "duel" "поединок"}
        {TRANSLATE_DESCRIPTION _"If this unit kills an enemy while neither unit has their allies next to them, the duelist gains inspiration for 3 turns (the duration stacks). If this unit attacks an enemy who is next to one of its allies, the duelist gains bravado for a turn." _"Если этот юнит убивает врага, когда рядом нет других бойцов, то он получает вдохновение. Если юнит атакует врага, возле которого стоят его (врага) союзники, то поединщик получает браваду на один ход."}
    [/duel]
    # wmlxgettext: [abilities]
[/abilities]
[event]
    id=ability_steppe_duel_die
    name=die
    first_time_only=no

    [filter]
        [not]
#check if there are any of the enemy's allies next to the enemy
            [filter_location]
                [filter]
                [filter_side]
                [allied_with]
                    side=$unit.side
                [/allied_with]
                [/filter_side]
                [not]
                    x,y=$x1,$y1
                    [or]
                    [filter_wml]
                        max_moves=0#stationary units do not count towards duel unit count
                    [/filter_wml]
                    [/or]
                [/not]
                [/filter]
                radius=1
            [/filter_location]
        [/not]
    [/filter]

    [filter_second]
        ability=steppe_duel
        [not]
#check if there are any of the duelist's allies next to the duelist
            [filter_location]
                [filter]
                [filter_side]
                [allied_with]
                    side=$second_unit.side
                [/allied_with]
                [/filter_side]
                [not]
                    x,y=$x2,$y2
                    [or]
                    [filter_wml]
                        max_moves=0#stationary units do not count towards duel unit count
                    [/filter_wml]
                    [/or]
                [/not]
                [/filter]
                radius=1
            [/filter_location]
        [/not]
    [/filter_second]

    {IF_VAR second_unit.variables.duel_turns_left greater_than 0 (
    [then]
    {VARIABLE_OP second_unit.variables.duel_turns_left add 3}
    [/then]
    [else]
    {VARIABLE second_unit.variables.duel_turns_left 3}
    [/else]
    )}

    [unstore_unit]
        variable=second_unit
#ifdef OGRE_RUSSIAN
        text="Дуель выиграна!"
#else
        text="Duel won!"
#endif
        find_vacant=no
    [/unstore_unit]

    [object]
        silent=yes
        duration=scenario
        [filter]
            find_in=second_unit
        [/filter]
        [effect]
           apply_to=new_ability
           [abilities]
               {ABILITY_STEPPE_INSPIRE}
               [dummy]
                  id=steppe_duel_buff
               [/dummy]
           [/abilities]
        [/effect]
    [/object]
[/event]



[event]
    id=ability_steppe_duel_attack
    name=attack
    first_time_only=no

    [filter]
        ability=steppe_duel
    [/filter]

    [filter_second]
        #check if the enemy has allies nearby
        [filter_location]
            [filter]
            [filter_side]
            [allied_with]
                side=$second_unit.side
            [/allied_with]
            [/filter_side]
            [not]
                x,y=$x2,$y2
                [or]
                [filter_wml]
                    max_moves=0#stationary units do not count towards duel unit count
                [/filter_wml]
                [/or]
            [/not]
            [/filter]
            radius=1
        [/filter_location]
        [not]
            [filter_wml]
                [status]
                    not_living="yes"
                [/status]
            [/filter_wml]
        [/not]
    [/filter_second]

    [unstore_unit]
        variable=unit
#ifdef OGRE_RUSSIAN
        text="Бравада!"
#else
        text="Bravado"
#endif
        find_vacant=no
        red=255
        green=126
        blue=0
    [/unstore_unit]

    [object]
        silent=yes
        duration=turn end
        [filter]
            id=$unit.id
        [/filter]
        [effect]
           apply_to=new_ability
           [abilities]
               {ABILITY_STEPPE_BRAVADO}
           [/abilities]
        [/effect]
    [/object]

[/event]

[event]
    name=side turn end
    id=steppe_duel_buff_event
    first_time_only=no

    [store_unit]
        [filter]
            ability=steppe_duel_buff
            side=$side_number
        [/filter]
        variable=steppe_duelists
        kill=no
    [/store_unit]

    [if]
    [variable]
        name=steppe_duelists.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH steppe_duelists i}

    {VARIABLE_OP steppe_duelists[$i].variables.duel_turns_left sub 1}
#    [chat]
#        message=$steppe_duelists[$i].variables.duel_turns_left
#    [/chat]
    [if]
    {VARIABLE_CONDITIONAL steppe_duelists[$i].variables.duel_turns_left less_than_equal_to 0}
    [then]
    {VARIABLE tmp_remove_duel_buff yes}
    {CLEAR_VARIABLE steppe_duelists[$i].variables.duel_turns_left}
    [/then]
    [/if]
        [unstore_unit]
            variable=steppe_duelists[$i]
            find_vacant=no
        [/unstore_unit]
    [if]
    {VARIABLE_CONDITIONAL tmp_remove_duel_buff equals yes}
    [then]
        [object]
            silent=yes
            duration=scenario
            [filter]
                id=$steppe_duelists[$i].id
            [/filter]
            [effect]
               apply_to=remove_ability
               [abilities]
               {ABILITY_STEPPE_INSPIRE}
               [dummy]
                  id=steppe_duel_buff
               [/dummy]
               [/abilities]
            [/effect]
        [/object]
    [/then]
    [/if]
    {NEXT i}
    {CLEAR_VARIABLE steppe_duelists}
    {CLEAR_VARIABLE tmp_remove_duel_buff}
    [/then]
    [/if]
[/event]
[event]
    name=victory
    id=steppe_clear_duel_buffs

    [store_unit]
        [filter]
            ability=steppe_duel_buff
            side=$side_number
        [/filter]
        variable=steppe_duelists
        kill=no
    [/store_unit]

    [if]
    [variable]
        name=steppe_duelists.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH steppe_duelists i}

    {CLEAR_VARIABLE steppe_duelists[$i].variables.duel_turns_left}
        [unstore_unit]
            variable=steppe_duelists[$i]
            find_vacant=no
        [/unstore_unit]
    {NEXT i}
    {CLEAR_VARIABLE steppe_duelists}
    [/then]
    [/if]
[/event]

#todo: add a victory event here that clears the duel turns variables of all duelists

[+abilities]
    # wmlxgettext: [/abilities]
#enddef
# wmllint: unbalanced-off

#define WEAPON_SPECIAL_STEPPE_HOLY_LIGHT
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    [damage]
        id=steppe_holy_light
        {TRANSLATE_ABILITY_HIDES _"holy light" _"благой свет"}
        {TRANSLATE_DESCRIPTION _"When this attack hits, enemies adjacent to this unit are damaged by 70% (rounded down) of this attack's damage, and adjacent allies are healed by 33% (rounded down) of the attack's damage." _"При попадании, враги стоящие вокруг юнита получают 70% (округлено вниз) урона этой атаки, а стоящие союзники лечатся на 33% (округлено вниз) от урона этой атаки."}
    [/damage]
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring
[event]
    name=attacker_hits
    id=steppe_holy_light
    first_time_only=no
    [filter_attack]
        special=steppe_holy_light
    [/filter_attack]

    {VARIABLE tmp_aoedmg $weapon.damage}
    {VARIABLE_OP tmp_aoedmg multiply 0.70}
    {VARIABLE_OP tmp_aoedmg round floor}
    {VARIABLE tmp_aoeheal $weapon.damage}
    {VARIABLE_OP tmp_aoeheal multiply 0.33}
    {VARIABLE_OP tmp_aoeheal round floor}

    [store_unit]
        [filter]
            [filter_adjacent]
                x,y=$x1,$y1
            [/filter_adjacent]
            [filter_side]
                [enemy_of]
                    side=$unit.side
                [/enemy_of]
            [/filter_side]
            [not]
                [filter_wml]
                    [status]
                        petrified=yes
                    [/status]
                [/filter_wml]
                [or]
                    id=$second_unit.id
                [/or]
            [/not]
        [/filter]
        variable=bystander
    [/store_unit]

    {FOREACH bystander i}
                [if]
                    [have_unit]
                        find_in=expfreeze
                        x,y=$bystander[$i].x,$bystander[$i].y
                    [/have_unit]
                    [else]
                    [fire_event]
                        name=attack
                        [primary_unit]
                            id=$unit.id
                        [/primary_unit]
                        [secondary_unit]
                            id=$bystander[$i].id
                        [/secondary_unit]
                    [/fire_event]
                    [store_unit]
                        [filter]
                            x,y=$bystander[$i].x,$bystander[$i].y
                        [/filter]
                        variable=expfreeze
                        mode=append
                    [/store_unit]
                    [/else]
                [/if]
                [harm_unit]
                    [filter]
                        x,y=$bystander[$i].x,$bystander[$i].y
                        [filter_side]
                            [enemy_of]
                                side=$unit.side
                            [/enemy_of]
                        [/filter_side]
                        [not]
                            [filter_wml]
                                [status]
                                    petrified=yes
                                [/status]
                            [/filter_wml]
                        [/not]
                    [/filter]
                    [filter_second]
                        x,y=$x1,$y1
                    [/filter_second]
                    [primary_attack]
                        name=$weapon.name
                        type=$weapon.type
                        range=$weapon.range
                    [/primary_attack]
                    amount=$tmp_aoedmg
                    damage_type=$weapon.type
                    alignment=$unit.alignment
                    fire_event=yes
                    animate=defender
                    delay=0
                    experience=no
                [/harm_unit]
                {VARIABLE damage_inflicted $tmp_aoedmg}
                [fire_event]
                    name=attacker_hits
                    [primary_unit]
                        id=$unit.id
                    [/primary_unit]
                    [secondary_unit]
                        id=$bystander[$i].id
                    [/secondary_unit]
                    [primary_weapon]
                        name=$weapon.name
                        type=$weapon.type
                        damage=$weapon.damage
                        range=$weapon.range
                    [/primary_weapon]
                [/fire_event]
    {NEXT i}
        [heal_unit]
            [filter]
                [filter_adjacent]
                    x,y=$x1,$y1
                [/filter_adjacent]
                [filter_side]
                    [allied_with]
                        side=$unit.side
                    [/allied_with]
                [/filter_side]
            [/filter]
            amount=$tmp_aoeheal
            animate=yes
            restore_statuses=no
        [/heal_unit]
    {CLEAR_VARIABLE tmp_aoedmg}
    {CLEAR_VARIABLE tmp_aoeheal}
[/event]

[event]
    name=defender_hits
    id=steppe_holy_light2
    first_time_only=no
    [filter_second_attack]
        special=steppe_holy_light
    [/filter_second_attack]

    {VARIABLE tmp_expfreeze_defense yes}#the expfreeze event checks this variable

    {VARIABLE tmp_aoedmg $second_weapon.damage}
    {VARIABLE_OP tmp_aoedmg multiply 0.70}
    {VARIABLE_OP tmp_aoedmg round floor}
    {VARIABLE tmp_aoeheal $second_weapon.damage}
    {VARIABLE_OP tmp_aoeheal multiply 0.33}
    {VARIABLE_OP tmp_aoeheal round floor}

    [store_unit]
        [filter]
            [filter_adjacent]
                x,y=$x2,$y2
            [/filter_adjacent]
            [filter_side]
                [enemy_of]
                    side=$second_unit.side
                [/enemy_of]
            [/filter_side]
            [not]
                [filter_wml]
                    [status]
                        petrified=yes
                    [/status]
                [/filter_wml]
                [or]
                    id=$unit.id
                [/or]
            [/not]
        [/filter]
        variable=bystander
    [/store_unit]

    {FOREACH bystander i}
                [if]
                    [have_unit]
                        find_in=expfreeze
                        x,y=$bystander[$i].x,$bystander[$i].y
                    [/have_unit]
                    [else]
                    [fire_event]
                        name=attack
                        [primary_unit]
                            id=$second_unit.id
                        [/primary_unit]
                        [secondary_unit]
                            id=$bystander[$i].id
                        [/secondary_unit]
                    [/fire_event]
                    [store_unit]
                        [filter]
                            x,y=$bystander[$i].x,$bystander[$i].y
                        [/filter]
                        variable=expfreeze
                        mode=append
                    [/store_unit]
                    [/else]
                [/if]
                [harm_unit]
                    [filter]
                        x,y=$bystander[$i].x,$bystander[$i].y
                        [filter_side]
                            [enemy_of]
                                side=$second_unit.side
                            [/enemy_of]
                        [/filter_side]
                        [not]
                            [filter_wml]
                                [status]
                                    petrified=yes
                                [/status]
                            [/filter_wml]
                        [/not]
                    [/filter]
                    [filter_second]
                        x,y=$x2,$y2
                    [/filter_second]
                    [primary_attack]
                        name=$second_weapon.name
                        type=$second_weapon.type
                        range=$second_weapon.range
                    [/primary_attack]
                    amount=$tmp_aoedmg
                    damage_type=$second_weapon.type
                    alignment=$second_unit.alignment
                    fire_event=yes
                    animate=defender
                    delay=0
                    experience=no
                [/harm_unit]
                {VARIABLE damage_inflicted $tmp_aoedmg}
                [fire_event]
                    name=defender_hits
                    [primary_unit]
                        id=$bystander[$i].id
                    [/primary_unit]
                    [secondary_unit]
                        id=$unit.id
                    [/secondary_unit]
                    [primary_weapon]
                        name=$second_weapon.name
                        type=$second_weapon.type
                        damage=$second_weapon.damage
                        range=$second_weapon.range
                    [/primary_weapon]
                [/fire_event]
    {NEXT i}
        [heal_unit]
            [filter]
                [filter_adjacent]
                    x,y=$x2,$y2
                [/filter_adjacent]
                [filter_side]
                    [allied_with]
                        side=$second_unit.side
                    [/allied_with]
                [/filter_side]
            [/filter]
            amount=$tmp_aoeheal
            animate=yes
            restore_statuses=no
        [/heal_unit]
    {CLEAR_VARIABLE tmp_aoedmg}
    {CLEAR_VARIABLE tmp_aoeheal}
[/event]

{STEPPE_EXPFREEZE_EVENT}
[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef